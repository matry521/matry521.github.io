## JVM垃圾回收机制

#### <font color="#0099ff">**范围:要回收哪些区域**</font>
JVM中有五种内存模型,其中程序计数器、JVM栈、本地方法栈不需要进行来及回收，因为他们的生命周期是和线程同步的，随着线程的销毁，内存会自动释放，
那么<font color="red" size="5">**方法区和堆**</font>是需要进行GC操作的。<br/>

#### <font color="#0099ff">**前提:如何判读对象已死**</font>
垃圾收集算法面临相同问题:**找出应用程序不可到达的内存块**，将其释放。<br/>
**不可达到**:主要是指应用程序已经没有内存块的引用了。<br/>
**可到达**:指这个对象被根(主要是指类的静态变量，或者活跃在所有线程栈的对象的引用)引用或者对象被另一个可到达的对象引用。<br/>

+ **引用计数器**
**原理**:在每个对象中增加一个引用的计数，代表当前程序有多少个引用引用了此对象，若此对象引用计数变为0，那么此对象就可以被垃圾回收器进行收集。<br/>
**优点**:简单直接，不需要暂停整个应用。<br/>
**缺点**:
A.需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作。<br/>
B.不能处理循环引用的问题
<font color="red">**说明:Sun的JVM并没有采用引用计数算法来进行垃圾回收，是基于根搜索算法。**</font>

+ **根搜索算法**
**原理**:通过一系列名为"GC Root"的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root
没有任何引用链相连时，则该对象不可达，该对象是不可能使用的，垃圾收集器将回收所占用的内存。<br/>
**以下几种对象可以作为GCRoot对象**:<br/>
(1)JVM栈(栈帧中的本地变量表)中的引用对象。<br/>
(2)方法区中的类静态属性引用的对象。<br/>
(3)方法区中的常量引用的对象。<br/>
(4)本地方法栈中JNI本地方法的引用对象。<br/>

<font color="red">**判定无用类**</font>:<br/>
(1)该类的所有实例都已经被回收，即Java堆中不存在该类的实例对象。<br/>
(2)加载该类的类加载器已经被回收。<br/>
(3)该类所对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射机制访问该类的方法。<br/>

+ **四种引用**
GC在收集一个对象的时候会判定是否有引用指向对象，在Java中的引用主要有四种:<br/>
(1)**强引用(Strong Reference)**<br/>
垃圾回收器绝不会回收具有强引用的对象。<br/>
当内存空间不足时，JVM宁愿抛出OutOfMemoryError异常来终止程序，也绝对不会回收强引用对象来解决内存不足问题。<br/>

(2)**软引用**<br/>
一个对象只有软引用，**若内存空间不足了，垃圾回收器就会回收这些对象的内存，否则不会回收**。<br/>
**软引用可用来实现内存敏感的高速缓存。**<br/>

(3)**弱引用(Weak Reference)**<br/>
与软引用区别:只具有弱引用的对象拥有更短暂的生命周期。<br/>
一旦发现只具有弱引用的对象，**不管当前内存空间足够与否，都会回收它的内存**。<br/>

(4)**虚引用(Phantom Reference)**<br/>
并不会决定对象的生命周期。任何时候都可能被垃圾回收器回收。<br/>
**虚引用主要用于检测对象是否已经从内存中删除，跟踪对象被垃圾回收器回收的活动**。<br/>
与软引用和弱引用的区别:**虚引用必须和引用队列(ReferenceQueue)联合使用**。

#### <font color="#0099ff">**策略:JVM中的垃圾收集策略**</font>

名称|特征|优点|缺点
---|----|----|----
标记-清除算法||1.解决循环引用问题<br/>2.不需要编译器配合，从而就不执行额外的指令|1.每个活跃的对象都要进行扫描，收集暂停的时间比较长<br/>2.采用从根集合进行扫描，对存活的对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收
复制算法||1.只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间|1.需要额外空间消耗，某一时刻，总有一块内存处于未使用状态<br/>2.复制对象需要一定的开销
标记-整理算法||集合了标记-清除算法和复制算法的优点|成本较高


