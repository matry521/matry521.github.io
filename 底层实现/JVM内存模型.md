## JVM内存模型

+ **JVM内存模型总体架构图**
    ![Image](../images/底层实现/JVM.png)
    
 **1.程序计数器** <br/>
    是一块较小的内存空间，可看作是当前线程执行字节码行号指示器。分支、循环、跳转、异常处理、
    线程恢复等功能都需要依赖计数器完成。<br/>
    JVM的多线程实现方式：线程轮流切换并分配处理器执行时间。(一个处理器只会执行一条线程中的指令)
    所以，每条线程需要一个独立的程序计数器，各线程间计数器互不影响，独立存储，使得线程切换后能恢复
    到正确的执行位置.(线程私有)<br/>
    (1)若线程正在执行的是一个Java方法，计数器记录的则为正在执行的虚拟机字节码指令的地址<br/>
    (2)若正在执行的是Native方法，计数器值则为空(Undefined)<br/>
    **此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域**<br/>
    
 **2.虚拟机栈** <br/>
    线程私有,与线程相同的生命周期。<br/>
    描述的是Java方法执行的内存模型: **每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于
    存储局部变量表、操作栈、动态链接、方法出口等信息.** <br/>
    对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为**当前栈帧**,这个栈帧所关联的方法称为
    **当前方法**。**执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作**。<br/>

  **(1)局部变量表** <br/>
    一组变量值存储空间，**用于存放方法参数和方法内部定义的局部变量**。Java程序被编译成class文件时
    通过方法Code属性的max_locals数据项配置最大局部变量表的容量。<br/>
    **变量槽(Slot)** 为局部变量表的最小单位。**虚拟机是使用局部变量表完成参数值到参数变量列表的传递
    过程的，** 若为实例方法(非static),局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的
    引用，在方法中通过this访问。<br/>
    Slot是可重用的，当Slot中变量超出了作用域，在下次分配Slot时候，将会覆盖原来的数据。<br/>
    Slot对对象的引用会影响GC(要是被引用，将不会被回收).<br/>
    **系统不会为局部变量赋予初始值(实例变量和类变量都会被赋予初始值)**。<br/>
  **(2)操作数栈** <br/>
    一个以字长为单位的数组。和局部变量区不同的是，不是通过索引来访问，而是通过标准的栈操作(压栈和出栈)
    来访问的。<br/>
    虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。<br/>
  **(3)动态链接** <br/>
    **静态解析**:符号引用在类加载阶段或者第一次使用的时候转化为直接引用<br/>
    **动态链接**:符号引用在运行期间转化为直接引用<br/>
  **(4)返回地址** <br/>
    **正常退出**:退出后会根据方法的定义来决定是否要传返回值给上层调用者。调用者的PC计数器的值可作
    为返回地址<br/>
    **异常退出**:不会传返回值给上层的调用方法。需要通过异常处理表来确定返回地址。<br/>
  **(5)异常** <br/>
    JVM规范中，规定了两种异常状况:<br/>
    **StackOverflowError异常**:线程请求的栈深度大于虚拟机所允许的深度。<br/>
    **OutOfMemoryError异常**:虚拟机可以动态扩展，当扩展时无法申请到足够的内存。<br/>
    
 **3.本地方法栈** <br/>
    **与虚拟机栈区别**:虚拟机栈是虚拟机执行Java方法(字节码)服务，本地方法栈为虚拟机使用到Native方法服务。<br/>
    本地方法栈区也会抛出**StackOverflowError** 和 **OutOfMemoryError** 异常。<br/>
    
 **4.堆** <br/>
    Java堆是被所有线程共享的一块内存区域，在**虚拟机启动时创建**。**此内存区域的唯一目的就是存放对象实例，**
    几乎所有对象实例都在这里分配内存。(JIT编译器发展与逃逸分析技术例外)<br/>
    **堆是垃圾收集器管理的主要区域**，很多时候也被称为""**GC堆**"<br/>
    **-Xms**:JVM启动时申请的最小内存，默认为**操作系统**物理内存的1/64但小于1G <br/>
    **-Xmx**:JVM可申请的最大内存，默认为物理内存的1/4但小于1G。<br/>
    当空余堆内存小于40%时，JVM会增大Heap的大小到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比例；
    当空余堆内存大于70%时，JVM会减少heap的大小到-Xms指定的大小，可通过-XX:MaxHeapFreeRation=来指定这个比例.
    
   
    